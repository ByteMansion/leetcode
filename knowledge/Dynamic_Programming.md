[toc]
# Dynamic Programming 动态规划
This document gives an brief introduction to dynamic programming.

## 动态规划 vs. 分治
动态规划 (dynamic programming, DP) 和分治方法类似，都是通过组合子问题的解来求解原问题(在这里，"programming" 指的是一种表格法，并非编写计算机程序)。

分治方法将问题划分为互不相交的子问题，递归地求解子问题，再将他们的解组合起来，求出原问题的解。

动态规划应用于**子问题重叠**的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治算法会做很多不必要的工作，它会反复地求解那些公共子子问题。而动态规划算法对每个子问题只求解一次，将其解保存在一个表格中，避免了每次求解一个子子问题时都重新计算。

## DP 用途和步骤
动态规划方法通常用来求解**最优化问题** (optimization problem)。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最大值或最小值）的解。我们称这样的解为问题的一个最优解 (an optimal solution)，而不是最优解 (optimal solution)，因为可能有多个解达到最优值。

通常有以下 4 个步骤设计 DP 算法：
1. 刻画一个最优解的结构特征；（最优子结构）
2. 递归地定义最优解的值；（状态转移方程）
3. 计算最优解的值，通常采用自底向上的方法；
4. 利用计算出的信息构造一个最优解。

步骤 1 ~ 3 是 DP 求解问题的基础。如果仅仅是需要一个最优解的值，而非解本身，可以忽略步骤 4。如果确实需要步骤 4，有时需要在执行步骤 3 的过程中维护一些额外信息，以便构造一个最优解。

> **最优子结构** (optimal substructure) 性质：一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列，换句话说，问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。

## DP 设计要素
1. 问题建模：优化的目标函数是什么？约束条件是什么？
2. 如何划分子问题（边界）？
3. 问题的优化函数值与子问题的优化函数值存在着什么依赖关系？（递推关系式）
4. 是否满足优化原则或最优子结构性质？
5. 最小问题怎么界定？其优化函数值，即初值等于什么？

## 两种算法
动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来。如果随后再次需要此子问题的解，只需查找保存结果，而不必重新计算。因此，DP 是以空间换时间，是典型的时空权衡 (time-memory tradeoff) 的例子。

DP 有两种等价的实现方法：
1. **带备忘的自顶向下法** (top-down with memoization)

此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解 (通常保存在一个数组或者散列中)。当需要一个子问题的解时，过程会首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省计算时间；否则，按通常方式计算这个子问题。称这个递归过程是**带备忘的** (memoized)，因为它“记住”了之前已经计算出的结果。

2. **自底向上法** (bottom-up method)

这种方法一般需要恰当定义子问题“规模”的概念，使得任何子问题的求解只依赖于“更小的”子问题的求解。因此，可以将子问题按照规模排序，按有小到大的顺序进行求解。当求解每个子问题时，它所依赖的那些更小的子问题都已经求解完毕。每个子问题只需求解一次。

>  两种方法得到的算法具有相同的渐进运行时间，仅有的差异是在某些特殊情况下，自顶向下方法并未真正递归地考察所有可能的子问题。由于没有频繁的递归函数调用的开销，自底向上方法的时间复杂性函数通常具有更小的系数。

## 钢条切割

给定一段长度为 $n$ 英寸的钢条和一个价格表 $p_i(i=1,2,3,...,n)$，求切割方案，使得销售收益 $r_n$ 最大。注意，如果长度为 $n$ 英寸的钢条的价格 $p_n$ 足够大，最优解可能就是完全不需要切割。

长度为 $i$ 英寸的钢条的价格为 $p_i(i=1,2,3,...)$ ，价格表样例如下：

|  长度 $i$   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| :---------: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 价格 $ p_i$ | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 24   | 30   |

考虑 $n=4$ 的情况，可能的切割方案有：

a) [ 4 ], $r_n = 9$ 

b) [ 1 3 ], $r_n = 1 + 8 = 9$

c) [ 2 2 ], $r_n = 5 + 5 = 10$

d) [ 3 1 ], $r_n = 8 + 1 = 9$

e) [ 1 1 2 ], $r_n = 1 + 1 + 5 = 7$

f) [ 1 2 1 ], $r_n = 1 + 5 + 1 = 7$

g) [ 2  1 1 ], $r_n = 5 + 1 + 1 = 7$

h) [ 1 1 1 1 ], $r_n = 1 + 1 + 1 + 1 = 4$

长度为 $n$ 英寸的钢条共有 $2^{n-1}$ 种不同的切割方案，因为在距离钢条左端 $i (i=1,2,...,n)$ 英寸处，总是可以选择切割还是不切割。

如果一个最优解是将钢条切割成 $k$ 段 (对某个 $1 \le k \le n$)，那么最优切割方案
$$
n = i_1 + i_2 + ... + i_k
$$
将钢条切割为长度分别为 $i_1, i_2, ..., i_k$ 的小段，得到的最大收益
$$
r_n = p_{i_1} + p_{i_2} + ... + p_{i_k}
$$
更一般的，对于 $r_n (n \ge 1)$，得到最优切割收益：
$$
r_n = max(p_n, r_1 + r_{n-1}, r_2 + r_{n-2}, ..., r_{n-1} + r_1)
$$
第一项 $p_n$ 对应不切割，直接出售长度为 $n$ 英寸的钢条方案。其他 $n-1$ 个参数对应 $n-1$ 个方案：对于每个 $i=1,2,...,n-1$ ，首先将钢条切割为长度为 $i$ 和 $n-i$ 两段，接着求解这两段的最优切割收益 $r_i$ 和 $r_{n-i}$ (每种方案的最优收益为两段的最优收益之和)。

注意到，为了求解规模为 $n$ 的原问题，先求解形式完全一样，但规模更小的子问题。即当完成首次切割后，将两段钢条看成两个独立的钢条切割问题实例。通过组合两个相关子问题的最优解，并在所有可能的两段切割方案中选取组合收益最大者，构成原问题的最优解。

很显然，上述方案可以采用**递归**地方式求解：将钢条从左边切割下长度为 $i$ 的一段，只对右边剩下的长度为 $n-i$ 的一段继续进行切割，左边长度不变。不做任何切割的方案就可以描述为：左边长度为 $n$ ，收益 $r_n$ 为 $p_n$，右边长度为 $0$ ，收益 $r_n$ 为 $0$。因此，公式 (3) 可以简化为：
$$
r_n = \max_{1\le i \le n}(p_i + r_{n-i})
$$

### 自顶向下递归实现

```latex
CUT-ROD(p, n)
  if n == 0
    return 0
  q = -inf
  for i = 1 to n
    q = max(q, p[i] + CUT-ROD(p, n-i))
  return q
```

$CUT-ROD$ 以价格数组 $p[1..n]$ 和整数 $n$ 为输入，返回长度为 $n$ 的钢条的最大收益。

此种方式，当输入规模变大，程序运行会特别慢，效率很低，原因在于，$CUT-ROD$ 反复地用相同的 参数值对自身进行递归调用，即反复求解相同的子问题。如 15.3 $n=4$ 的示意图。

![15.3](/Users/Changrui/changrui/c++/leetcode/knowledge/pic/15.3.png)

#### 时间复杂度

令 $T(n)$ 表示第二个参数值为 $n$ 时 $CUT-ROD$ 的调用次数，此值等于递归调用树中根为 $n$ 的子树中的节点总数，注意，此值包含了根节点对应的最初一次调用，因此 $T(0) = 1$，且
$$
T(n) = 1 + \sum^{n-1}_{j=0}T(j)
$$
第一项 ”1“ 表示函数的第一次调用 (递归调用树的根节点)，$T(j)$ 为调用 $CUT-ROD(p, n-i)$ 所产生的所有调用 (包括递归调用) 的次数。求得
$$
T(n) = 2^n
$$

### 带备忘的自顶向下方法

通过上面的分析可以看到，大量的重复计算子问题导致指数级的时间复杂度，如果我们采用备忘的机制，依次记录下子问题的解，当在后续递归中需要子问题的解时，直接使用备忘录中的值，而不需要再次递归。

```latex
CUT-ROD(p, n)
	let r[0..n] be a new array
	for i = 0 to n
		r[i] = -inf
	return MEMOIZED-CUT-ROD(p, n, r)
	
MEMOIZED-CUT-ROD(p, n, r)
	if r[n] >= 0
		q = r[n]
	if n == 0
		return 0
	else 
		q = -inf
		for i = 1 to n
			q = max(q, p[i] + MEMOIZED-CUT-ROD(p, n, r))
	r[n] = q
	return q
```

这里主要过程 $MEMOIZED-CUT-ROD$ 将辅助数组 $r[0..n]$ 的元素均初始化为 $-inf$ ，作为子问题解的备忘录。

### 自底向上方法

自底向上的方法更简单，从小到大的依次解决子问题并存在表中。

```latex
BOTTOM-UP-CUT-ROD(p, n)
	let r[0..n] be a new array
  r[0] = 0
  for j = 1 to n
  	q = -inf
  	for i = 1 to j
  		q = max(q, p[i] + r[j-i])
  	r[j] = q
  return r[n]
```

若 $i \lt j$，则规模为 $i$ 的子问题比规模为 $j$ 的子问题”更小“，因此，上述过程依次求解规模为 $j=0,1,...,n$ 的子问题。

#### 时间复杂度

上述两种方法有相同的渐进运行时间。自底向上的方法比较直观，嵌套循环，时间复杂度为 $\Theta(n^2)$ 。自顶向下的方法稍微复杂：当求解一个之前已计算出结果的子问题是，递归调用会立即返回，即 $MEMOIZED-CUT-ROD$  对每个子问题只会求解一次，子问题的规模为 $0,1,2,...,n$，需要经过 $n$ 次迭代，因此时间复杂度还是 $\Theta(n^2)$。

### 子问题图

当思考一个动态规划问题时，应该弄清所涉及的子问题及子问题之间的依赖关系。问题的**子问题图**准确地表达了这些信息。

图 15.4 显示了 $n=4$ 时钢条切割问题的子问题图。
![subproblem graph](./pic/subproblem_graph.png)
它是一个**有向图**，每个顶点唯一地对应一个子问题。在求子问题 $x$ 的最优解是需要直接用到子问题 $y$ 的最优解，那么在子问题图中就会有一条从子问题 $x$ 到子问题 $y$ 的顶点的有向边。

可以将子问题图看做自顶向下递归调用树的“简化版”或者“收缩版”，因为树中所有对应相同子问题的节点合并为图中的单一顶点，相关的所有边都从父结点指向子结点。

自底向上向上的 DP 方法处理子问题图中顶点的顺序为：对于一个给定的子问题 $x$，在求解它之前求解邻接至它的子问题 $y$ (邻接关系不一定是对称的)。用第 22 章中的术语说，自底向上 DP 是按“拓扑逆序” (reverse topological sort) 或“反序的拓扑序” (topological sort of the transpose) (chapter 22.4) 来处理子问题图中的顶点。换句话说，对于任何子问题，直至它依赖的所有子问题均已求解完成，才会求解它。类似的，可以用“深度优先搜索” (depth-first search) (chapter 22.3) 来描述（带备忘机制的）自顶向下动态规划算法处理子问题图的顺序。

子问题图 $G=(V, E)$ 的规模可以帮助我们确定动态规划算法的运行时间。由于每个子问题只求解一次，因此算法运行时间等于每个子问题求解时间之和。**通常，一个子问题的求解时间与子问题图中对应顶点的度（出射边的数目）称正比，而子问题的数目等于子问题图的顶点数。** 因此，*通常情况下，动态规划算法的运行时间与顶点和边的数量称线性关系。*

## 典型问题
|问题|参考书目|
|--|--|
|钢条切割|算法导论15.1|
|矩阵乘法|算法导论15.2|
|最长公共子序列|算法导论15.4|
|最优二叉搜索树|算法导论15.5|
|背包问题|-|
|最短路径问题|-|

## Reference
1. Introduction to Algorithms, 3rd version 算法导论，第三版 
2. 算法设计与分析课程

## 扩展
聚合分析 (aggregate analysis)（算法导论 17.1）

